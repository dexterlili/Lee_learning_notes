# 绪论

## 研究内容

计算机解决问题的**步骤**：

1. 具体问题抽象为**数学模型**
   1. 分析问题
   2. 提取操作对象
   3. 找出操作对象之间的关系
   4. 用数学语言描述（**2、3、4数据结构**）
2. 设计算法
3. 编程、调试、运行

- **数据结构**是一门研究**非数值计算**的程序设计中计算机的**操作对象**以及它们之间的**关系**和**操作**的学科
- **程序设计=数据结构+算法**
  - 数据结构通过算法实现操作
  - 算法根据数据结构设计程序

## 基本概念和术语

- **数据**`Data`

  - 前提：可以输入到计算机中；能被计算机程序处理

  各种符号的集合：

  - 数值型：整数、实数等
  - 非数值型：文字、图像、声音等

- **数据元素**`Data Element`

  数据的**基本单位**，通常作为一个整体进行考虑和处理（简称元素、也可称记录、节点或顶点）

  - 与数据的关系：是集合的个体

- **数据项**`Data Item`

  构成数据元素的不可分割的**最小单位**

  数据> 数据元素> 数据项

  eg:

  ​	学生表> 个人纪录> 学号、姓名......

- **数据对象**`Data Object`

  **性质相同的数据元素的集合**，是数据的子集

  - 与数据的关系：集合的子集

- **数据结构**`Data Structure`

  定义`definition`：**是相互之间存在一种或多种特定关系的数据元素的集合。**

  - **逻辑**结构：数据元素之间的逻辑关系，与存储无关，独立于计算机，抽象出来的数学模型

    - 线性结构：有且仅有一个开始和终端结点，最多一个直接前驱和直接后继

      eg：线性表、栈、队列、串

    - 非线型结构：一个结点可能有多个直接前驱和直接后继

      eg：树、图

    - 四种基本逻辑结构

      - 集合：同属于一个集合
      - 线性：1对1的线性关系
      - 树形：1对多的层次关系
      - 图状或网状：多对多的任意关系

  - **物理/存储**结构：数据元素及其关系在内存中的表示（也称映像），数据的逻辑结构在计算机中的存储形式，在计算机内部的表示

    - **顺序**存储

      用一组**连续**的存储单元**依次**存储数据元素，数据元素之间的逻辑关系由元素的**存储位置**来表示

    - **链式**存储

      用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用**指针**来表示

    - 索引存储

      在存储结点信息的同时，还建立附加的**索引表**（关键字，地址）

      eg：手机通讯录

    - 散列存储

      根据结点的关键字直接计算出该节点的存储地址

  - 实现和运算：对数据元素可以进行的操作和这些操作在相应的存储结构上的实现

  - 注：**逻辑机构和存储结构的关系**

    - 存储结构是逻辑关系的映像与元素本身的映像

    - 逻辑结构是数据结构的抽象，存储结构是数据结构的实现

- **数据类型**`Data Type`

  - 定义：是一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总称
  - 基本数据类型，构造数据类型，指针、空`void`类型、也可自己定义`typedef`
  - 约束变量或常量的**取值范围**；约束变量或常量的**操作**

- **抽象数据类型**`Abstract Data Type`(ADT)

  - 定义：指一个数学模型以及定义在此数学模型上的一组操作

  - 由用户定义，从问题抽象出**数据模型**（逻辑结构）

  - 还包括定义在数据模型上的一组**抽象运算**（相关操作）

  - 不考虑计算机内部的具体存储结构和运算的具体实现算法

    定义格式
    ADT 抽象数据类型名{
    	数据对象:<定义>	//伪代码描述
    	数据关系:<定义>	//伪代码描述
    	基本操作:<定义>
    }ADT 抽象数据类型名

    基本操作定义格式：
    基本操作名(参数名)
    初始条件: <初始条件描述>
    操作结果: <操作结果描述>
    eg:
    ADT Circle{
    	数据对象: D={r,x,y| r,x,y均为实数}
    	数据关系: R={<r,x,y>| r是半径, <x,y>是圆心坐标}
    	基本操作:
    	Circle(&C,r,x,y)	操作结果：构造一个圆
    	double Area(C)	初始条件：圆已经存在
    					操作结果：计算面积
    	double Circumference(C)
    					初始条件：圆已经存在
    					操作结果：计算周长
    	......
    }ADT Circle

- 参数表：**赋值参数**只为操作提供输入值；**引用参数**以&打头，既可提供输入值，还将返回操作结果

## 算法与算法分析

> Algorithm

- 定义`definition`：是解决特定问题**求解方法和步骤**的一种描述，在计算机中表现为==指令==的有限==序列==，并且每条指令可以表示一个或多个操作。

- 描述：自然语言；流程图（传统、NS）；伪代码；程序代码（C、C++、java）

- 算法与程序

  - 算法是解决问题的不同种方法，考虑如何将输入转换成输出，一个问题可有多种算法
  - 程序是用某钟程序设计语言对算法的具体实现

- 特性（5个）：

  - 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
  - 确定性：每一步骤都具有确定的含义，不会出现二义性，相同的输入只有唯一的输出结果
  - 可行性：每一步都必须是可行的，每一步都能通过执行有限次数完成
  - 输入：零个或多个输出
  - 输出：至少有一个或多个输出

- 要求（4个）：

  - 正确性`Correctness`
    - 无语法错误
    - 对于合法的输入数据能够产生满足要求的输出结果。
    - 对于非法的输入数据能够得出满足规格说明的结果。（第3层作为一个算法是否正确的标准）
    - 对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
  - 可读性`Readability`：人能看懂并且交流讨论并且调试
  - 健壮性`Robustness`：
    - 碰到非法数据时，会做出相应的反应，而不是莫名其妙的结果
    - 处理出错的方式，不应该是终端程序的执行
  - 高效性`Efficiency`：时间效率高，存储量低，即时间复杂度和空间复杂度
    - 事后统计：算法实现后测算时间和空间开销
    - 事前分析：估算（更多使用）

- 时间效率

  - 算法运行时间=$\Sigma$每条语句频度*该语句执行一次所需的时间

  - 仅比较数量级; `T(n)=O(f(n))`,算法的渐进**时间复杂度**

  - 只考虑算法中**基本操作**执行的次数，它是**问题规模n**的某个函数

  - 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法

  - 基本操作重复次数也与问题的输入数据集有关

  - 计算时间复杂度：

    - 忽略所有**低次幂项和最高次幂系数**，体现出增长率的含义

    - 由嵌套最深层语句的频度决定的

    - 找执行次数最多的语句；找出关于问题规模n的函数；找出数量级

    - 最坏情况；平均情况；最好情况

    - 加法规则：

      Y(n) = T~1~(n) + T~2~(n) = O( f(n) ) + O( g(n) ) = O( *max*( f(n) , g(n) ) )

    - 乘法规则：

      Y(n) = T~1~(n) * T~2~(n) = O( f(n) ) * O( g(n) ) = O( f(n) * g(n) ) 

    - 比较：

      | 名称（由低到高） |     表示     |
      | :--------------: | :----------: |
      |      常数阶      |     O(1)     |
      |      对数阶      |  O(log~2~n)  |
      |      线性阶      |     O(n)     |
      |    线性对数阶    | O(n*log~2~n) |
      |      平方阶      |   O(n^2^)    |
      |      立方阶      |   O(n^3^)    |
      |       ...        |     ...      |
      |     k次方阶      |   O(n^k^)    |
      |      指数阶      |   O(2^n^)    |

      O(1)<O(logn)<O(n)<O(n*logn)<O(n^2^)<O(n^3^)<O(2^n^ )<O(n!)<O(n^n^)

      注：对数下标可忽略

- 空间效率

  - 算法所需存储空间的度量
  - S(n) = O( f(n) )；n为问题的规模
  - 算法本身要占据的空间、输入/输出、指令、常数、变量等、辅助空间
